@page "/training"
@using BrothersEnglishApp.Models
@using BrothersEnglishApp.Services
@inject LocalStorageService Storage
@inject NavigationManager Nav
@inject UserContext Context
@inject IJSRuntime JS   // JavaScript呼び出し用
@inject WordRepository WordRepo // 単語リポジトリの注入
@inject TrainingEngine Engine // トレーニングエンジンの注入

<PageTitle>トレーニング</PageTitle>

@if (currentWord == null)
{
    <div class="text-center mt-5">
        <span class="display-1">🎉</span>
        <h4 class="mt-3">今日の目標達成！</h4>
        <p class="fs-5">@(Context.CurrentUser)くん、よく頑張ったね！</p>

        <div class="d-grid gap-3 col-10 col-md-6 mx-auto mt-4">
            @* メインの動線：ふくしゅうへ *@
            <button class="btn btn-success btn-lg shadow-sm py-3" @onclick='() => Nav.NavigateTo("study")'>
                <i class="bi bi-play-circle-fill me-2"></i>今日の復習をする
            </button>

            @* サブの動線：ホームへ *@
            <button class="btn btn-outline-secondary" @onclick='() => Nav.NavigateTo("/")'>
                TOPへ戻る
            </button>
        </div>
    </div>
}
else
{
    <div class="container-fluid mt-2 text-center">
        @* --- 追加：進捗とユーザー名を表示するエリア --- *@
        <div class="d-flex justify-content-between align-items-center mb-2 px-2">
            <div class="text-start">
                <span class="badge bg-secondary">ユーザー: @Context.CurrentUser</span>
            </div>
            <div class="text-end text-muted small">
                @* Engineに現在の進捗を計算させるか、ここで簡易計算 *@
                <strong>@GetCurrentProgress()</strong> / @appSettings.DailyGoal 問目
            </div>
        </div>

        @* プログレスバー（視覚的に進み具合を見せる） *@
        <div class="progress mb-3" style="height: 10px;">
            <div class="progress-bar progress-bar-striped progress-bar-animated bg-success" 
                 role="progressbar" 
                 style="width: @(GetProgressPercentage())%"></div>
        </div>

        @* containerをfluidにして横幅を有効活用 *@
        @* ステップ表示を少しコンパクトに *@
        <div class="text-center mb-4">
            <div class="d-flex justify-content-center align-items-end flex-column">
                <div class="form-check form-switch mt-2">
                    <input class="form-check-input" type="checkbox" id="autoSpeech"
                           @bind="appSettings.IsAutoSpeechEnabled" @oninput="ToggleAutoSpeech" />
                    <label class="form-check-label small text-muted" for="autoSpeech">
                        単語読み上げ
                    </label>
                </div>
            </div>
        </div>
        
        <div class="badge rounded-pill @(isReviewing ? "bg-danger" : "bg-warning text-dark") mb-2 px-4 py-3">
            @if (isReviewing)
            {
                <span>👀 よく見て覚えよう！</span>
            }
            else
            {

                <span>@(isStep2 ? "🔥 見ないで入力！" : "📝 お手本通り入力！")</span>
            }
        </div>

        <div class="card shadow-sm p-3 mb-2">
            @* お手本エリア：スマホで見やすい高さに *@
            <div class="bg-light py-3 rounded mb-3" style="min-height: 80px; display: flex; align-items: center; justify-content: center;">
                @if (isReviewing || !isStep2)
                {
                    <h2 class="display-4 fw-bold text-primary mb-0">@currentWord.Word</h2>
                    <div class="text-muted fs-4 ps-1">
                        @currentWord.IPA@* ここで発音記号を表示 *@
                    </div>

                }
                else
                {
                    <h2 class="display-4 fw-bold text-muted mb-0" style="opacity: 0.1;">????</h2>

                }
            </div>
            
            @* 単語情報エリア *@
            <div class="mb-3">
                <div class="text-center my-4">
                    <span class="badge bg-success ">@currentWord.PartOfSpeech</span>
                    @* スピーカーボタン。クリックで Speak メソッドを実行！ *@
                    <button class="btn btn-outline-primary rounded-circle"
                            @onclick="() => Speak(currentWord.Word)"
                            title="音声を再生">
                        <i class="bi bi-volume-up-fill"></i>
                    </button>
                </div>
                <h2 class="fw-bold mt-1 mb-0" style="font-size: calc(1.5rem + 1.5vw);">@currentWord.Meaning</h2>
             </div>


            @if (isReviewing)
            {
                @* 修正：スマホで押しやすい、画面中央の巨大なボタン *@
                <button class="btn btn-danger btn-lg w-100 shadow py-4 fs-3" @onclick="EndReview">
                    覚えた！もう一度入力🚀
                </button>
            }
            else
            {
                <div class="form-group mb-2">
                    @* 修正後：スマホ最適化＋間違えた時の震え演出を追加！ *@
                    <input @ref="wordInput"
                           @bind="userInput"
                           @bind:event="oninput"
                           @onkeyup="HandleKeyUp"
                           class="form-control form-control-lg text-center fs-1 py-3 @(isWrong ? "shake border-danger text-danger" : "")"
                           type="text"
                           autocomplete="off"
                           autocorrect="off"
                           spellcheck="false"
                           placeholder="入力してね" />
                </div>
            }

            @if (isCorrect)
            {
                <div class="alert alert-success py-2 mt-2 shadow-sm">✨ 正解！ ✨</div>
            }
        </div>
    </div>
}

@code {
    private List<EnglishWord>? allWords;
    private UserProgress? userProgress;
    private EnglishWord? currentWord;
    private ElementReference wordInput;
    private string userInput = "";
    private bool isStep2 = false;
    private bool isCorrect = false;
    private bool isReviewing = false; // 復習モードかどうか
    private bool isWrong = false; // 震えさせるためのフラグ
    private AppSettings appSettings = new();

    // コンポーネント初期化時の処理
    protected override async Task OnInitializedAsync()
    {
        if (!Context.IsSelected)
        {
            Nav.NavigateTo("/");
            return;
        }

        // サーバーから最新の単語リストをダウンロードする
        allWords = await WordRepo.GetWordsAsync();
        userProgress = await Storage.LoadAsync<UserProgress>($"User_{Context.CurrentUserId}")
                ?? new UserProgress { UserName = Context.CurrentUser };

        // 他の読み込み処理と一緒に AppSettings もロードする
        var savedSettings = await Storage.LoadAsync<AppSettings>("AppSettings");
        if (savedSettings != null) appSettings = savedSettings;

        await SelectNextWord();
    }

    // トグルが切り替わった時に保存する
    private async Task ToggleAutoSpeech(ChangeEventArgs e)
    {
        appSettings.IsAutoSpeechEnabled = (bool)e.Value!;
        await Storage.SaveAsync("AppSettings", appSettings);
    }

    // 今何問目かを計算する
    private int GetCurrentProgress()
    {
        if (userProgress == null) return 0;
        // 今日正解した単語数 + 1（今解いている分）を返す
        var todayDone = userProgress.WordStatuses.Count(s =>
            s.LastReviewed.Date == DateTime.UtcNow.Date && s.Status >= 1);

        // 目標数を超えないように調整
        return Math.Min(todayDone + 1, appSettings.DailyGoal);
    }

    // プログレスバーの％を計算
    private double GetProgressPercentage()
    {
        var current = GetCurrentProgress() - 1; // 解き終わった数
        return ((double)current / appSettings.DailyGoal) * 100;
    }

    // 次の単語を選ぶメソッド
    private async Task SelectNextWord()
    {
        if (allWords == null || userProgress == null) return;

        // 複雑な判定は Engine に任せる！
        currentWord = Engine.GetNextWord(allWords, userProgress, appSettings.DailyGoal);

        userInput = "";
        isStep2 = false;
        isCorrect = false;
        isReviewing = false;

        StateHasChanged();

        // 画面が切り替わるのを一瞬待ってから、入力欄にフォーカスを当てる
        if (currentWord != null)
        {
            await Task.Delay(10);
            await JS.InvokeVoidAsync("speechHandlers.focusElement", wordInput);

            if (appSettings.IsAutoSpeechEnabled)
            {
                await Task.Delay(300);
                await Speak(currentWord.Word);
            }
        } else
        {
             // ★目標達成した時のフラグ処理を追加
            var todayKey = DateTime.UtcNow.ToString("yyyyMMdd");
            if (!userProgress.ActivityLog.ContainsKey(todayKey))
            {
                userProgress.ActivityLog[todayKey] = new DayActivity();
            }
            userProgress.ActivityLog[todayKey].TrainingDone = true;

            // 保存を忘れずに！
            await Storage.SaveAsync($"User_{Context.CurrentUserId}", userProgress);
        }
    }

    // ユーザーの回答をチェックするメソッド
    private async Task CheckAnswer()
    {
        if (currentWord == null || userProgress == null || isReviewing) return;

        // 審判に判定を任せる
        var result = Engine.ProcessAnswer(userInput, currentWord, userProgress, isStep2);

        if (result.IsCorrect)
        {
            isCorrect = true;
            StateHasChanged();
            await Task.Delay(600);

            if (result.ShouldGoToStep2)
            {
                isStep2 = true;
                isCorrect = false;
                userInput = "";
            }
            else if (result.IsFinished)
            {
                // 保存して次へ
                await Storage.SaveAsync($"User_{Context.CurrentUserId}", userProgress);
                await SelectNextWord();
            }
        }
        else
        {
            if (result.ShouldStartReview)
            {
                await Storage.SaveAsync($"User_{Context.CurrentUserId}", userProgress);
                isReviewing = true;
                userInput = "";
            }
            else
            {
                // Step1でのミス、または空文字など
                isWrong = true;
                StateHasChanged();
                await Task.Delay(500);
                isWrong = false;
            }
        }
        StateHasChanged();
    }

    // 「覚えた！」ボタンを押した時
    private async Task EndReview()
    {
        isReviewing = false;
        userInput = "";
        StateHasChanged();

        // 画面が切り替わるのを一瞬待ってから、入力欄にフォーカスを当てる
        await Task.Delay(10);
        await JS.InvokeVoidAsync("focusElement", wordInput);
    }

    // Enterキーでの送信対応
    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter") await CheckAnswer();
    }

    // 単語を読み上げるメソッド
    private async Task Speak(string text)
    {
        // eval ではなく、定義した関数名を直接呼ぶ！
        // 引数（text）を渡すだけなので、シングルクォートの考慮も不要で安全
        await JS.InvokeVoidAsync("speechHandlers.speak", text);
    }
}